name: PR Review

on:
  pull_request_target:
    types: [opened]
  workflow_dispatch:
    inputs:
      prNumber:
        description: 'The number of the PR to review manually'
        required: true
        type: string

jobs:
  review-pr:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    env:
      PR_NUMBER: ${{ github.event.pull_request.number || inputs.prNumber }}

    steps:
      - name: Generate GitHub App Token
        id: generate_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.BOT_APP_ID }}
          private-key: ${{ secrets.BOT_PRIVATE_KEY }}

      - name: Configure Git for Bot
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        run: |
          git config --global user.name "mirrobot-agent[bot]"
          git config --global user.email "${{ secrets.BOT_APP_ID }}+mirrobot-agent@users.noreply.github.com"
          git config --global url."https://x-access-token:${{ steps.generate_token.outputs.token }}@github.com/".insteadOf "https://github.com/"

      - name: Fetch and Format Full PR Context
        id: pr_meta
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        run: |
          # Fetch all PR data, including new fields like files, commits, additions, etc.
          pr_json=$(gh pr view ${{ env.PR_NUMBER }} --repo ${{ github.repository }} --json author,title,body,createdAt,state,headRefName,baseRefName,headRefOid,additions,deletions,commits,files,comments,reviews,closingIssuesReferences)
          
          # For checkout step
          echo "repo_full_name=$(echo "$pr_json" | jq -r .headRepository.nameWithOwner)" >> $GITHUB_OUTPUT
          echo "ref_name=$(echo "$pr_json" | jq -r .headRefName)" >> $GITHUB_OUTPUT

          # Prepare metadata
          author=$(echo "$pr_json" | jq -r .author.login)
          created_at=$(echo "$pr_json" | jq -r .createdAt)
          base_branch=$(echo "$pr_json" | jq -r .baseRefName)
          head_branch=$(echo "$pr_json" | jq -r .headRefName)
          state=$(echo "$pr_json" | jq -r .state)
          additions=$(echo "$pr_json" | jq -r .additions)
          deletions=$(echo "$pr_json" | jq -r .deletions)
          total_commits=$(echo "$pr_json" | jq -r '.commits | length')
          changed_files_count=$(echo "$pr_json" | jq -r '.files | length')
          title=$(echo "$pr_json" | jq -r .title)
          body=$(echo "$pr_json" | jq -r .body)

          # Prepare changed files list
          changed_files_list=$(echo "$pr_json" | jq -r '.files[] | "- \(.path) (MODIFIED) +\((.additions))/-((.deletions))"')

          # Prepare comments
          comments=$(echo "$pr_json" | jq -r 'if (.comments | length) > 0 then .comments[] | "- \(.author.login // "unknown") at \(.createdAt // "N/A"):\n\(.body // "")\n" else "No general comments." end')

          # Prepare reviews (more complex formatting)
          reviews=$(echo "$pr_json" | jq -r 'if (.reviews | length) > 0 then .reviews[] | "- \(.author.login // "unknown") at \(.createdAt // "N/A"):\n  - Review body: \(.body // "No summary comment.")\n" + (if .comments | length > 0 then "  - Comments:\n" + (.comments.nodes[] | "    - \(.path):\(.line): \(.body // "")\n") else "" end) else "No formal reviews." end')
          
          # Prepare linked issues
          linked_issues=$(echo "$pr_json" | jq -r 'if (.closingIssuesReferences.nodes | length) > 0 then .closingIssuesReferences.nodes[] | "<issue>\n <number>#\(.number)</number>\n <title>\(.title // "Title not available")</title>\n <body>\n\(.body // "Body not available")\n</body>\n</issue>\n" else "No issues are formally linked for closure by this PR." end')

          # Assemble the final context block
          PR_CONTEXT=$(cat <<EOF
          Author: $author
          Created At: $created_at
          Base Branch: $base_branch
          Head Branch: $head_branch
          State: $state
          Additions: $additions
          Deletions: $deletions
          Total Commits: $total_commits
          Changed Files: $changed_files_count files

          <pull_request_body>
          $title
          ---
          $body
          </pull_request_body>

          <pull_request_comments>
          $comments
          </pull_request_comments>

          <pull_request_reviews>
          $reviews
          </pull_request_reviews>

          <pull_request_changed_files>
          $changed_files_list
          </pull_request_changed_files>

          <linked_issues>
          $linked_issues
          </linked_issues>
          EOF
          )
          # Export for the next step
          { echo "PULL_REQUEST_CONTEXT<<EOF"; echo "$PR_CONTEXT"; echo "EOF"; } >> "$GITHUB_ENV"
          echo "PR_HEAD_SHA=$(echo "$pr_json" | jq -r .headRefOid)" >> $GITHUB_ENV
          echo "PR_AUTHOR=$author" >> $GITHUB_ENV

      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.pr_meta.outputs.repo_full_name }}
          ref: ${{ steps.pr_meta.outputs.ref_name }}
          token: ${{ steps.generate_token.outputs.token }}
          fetch-depth: 0

      - name: Inject Custom Config (For Proxy Support)
        run: |
          mkdir -p ~/.config/opencode
          # Build and write opencode.json with secrets
          CONFIG='{
            "$schema": "https://opencode.ai/config.json",
            "provider": {
              "llm-proxy": {
                "npm": "@ai-sdk/openai-compatible",
                "name": "Proxy",
                "options": {
                  "baseURL": "${{ secrets.PROXY_BASE_URL }}",
                  "apiKey": "${{ secrets.PROXY_API_KEY }}",
                  "headers": {
                    "User-Agent": "OpenCode/1.0",
                    "X-Custom-Header": "your-value"
                  }
                },
                "models": {
                  "${{ secrets.OPENCODE_MODEL }}": {
                    "name": "Custom Model",
                    "limit": {
                      "context": 262000,
                      "output": 64192
                    }
                  }
                }
              }
            },
            "autoupdate": true
          }'
          echo "$CONFIG" > ~/.config/opencode/opencode.json

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-3.12-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-3.12

      - name: Install dependencies
        run: |
          pip install -r requirements.txt

      - name: Install opencode
        run: curl -fsSL https://opencode.ai/install | bash

      - name: Ensure opencode directory exists
        run: mkdir -p /home/runner/.local/share/opencode/project

      - name: Review PR comprehensively
        env:
          OPENCODE_API_KEY: ${{ secrets.PROXY_API_KEY }}
          GITHUB_TOKEN: ${{ steps.generate_token.outputs.token }}
          OPENCODE_PERMISSION: |
            {
              "bash": {
                "gh*": "allow",
                "git*": "allow"
              },
              "webfetch": "deny"
            }
        run: |
          # Use a heredoc (<<'END_OF_PROMPT') to pass the prompt safely via stdin.
          # The "-" tells the opencode command to read the prompt from stdin.
          opencode run --share -m llm-proxy/${{ secrets.OPENCODE_MODEL }} - <<'END_OF_PROMPT'
          # [ROLE AND OBJECTIVE]
          You are an expert AI code reviewer. Your goal is to provide meticulous, constructive, and actionable feedback by posting it directly to the pull request as a series of commands.

          # [Your Identity]
          You operate under the names **mirrobot**, **mirrobot-agent**, or the git user **mirrobot-agent[bot]**. When analyzing thread history, recognize actions by these names as your own.

          # [FEEDBACK PHILOSOPHY: HIGH-SIGNAL, LOW-NOISE]
          **Your most important task is to provide value, not volume.** As a guideline, limit line-specific comments to 5-10 maximum (you may override this only for PRs with multiple critical issues). Avoid overwhelming the author. Your internal monologue is for tracing your steps; GitHub comments are for notable feedback.

          **Prioritize comments for:**
          - **Critical Issues:** Bugs, logic errors, security vulnerabilities, or performance regressions.
          - **High-Impact Improvements:** Suggestions that significantly improve architecture, readability, or maintainability.
          - **Clarification:** Questions about code that is ambiguous or has unclear intent.

          **Do NOT comment on:**
          - **Trivial Style Preferences:** Avoid minor stylistic points that don't violate the project's explicit style guide. Trust linters for formatting.
          - **Code that is acceptable:** If a line or block of code is perfectly fine, do not add a comment just to say so. No comment implies approval.
          - **Duplicates:** Explicitly cross-reference the discussion in `<pull_request_comments>` and `<pull_request_reviews>`. If a point has already been raised, skip it. Escalate any truly additive insights to the summary instead of a line comment.

          **Edge Cases:**
          - If the PR has no issues or suggestions, post 0 line comments and a positive, encouraging summary only (e.g., "This PR is exemplary and ready to merge as-is. Great work on [specific strength].").
          - **For large PRs (>500 lines changed or >10 files):** Focus on core changes or patterns; note in the summary: "Review scaled to high-impact areas due to PR size."
          - **Handle errors gracefully:** If a command would fail, skip it internally and adjust the summary to reflect it (e.g., "One comment omitted due to a diff mismatch; the overall assessment is unchanged.").

          # [PULL REQUEST CONTEXT]
          This is the full context for the pull request you must review.
          <pull_request>
          ${{ env.PULL_REQUEST_CONTEXT }}
          </pull_request>
          
          # [REVIEW GUIDELINES & CHECKLIST]
          Before writing any comments, you must first perform a thorough analysis based on these guidelines. This is your internal thought processâ€”do not output it.
          1.  **Identify the Author:** First, check if the PR author (`${{ env.PR_AUTHOR }}`) is one of your own identities (mirrobot, mirrobot-agent, mirrobot-agent[bot]). This check is crucial as it dictates your entire review style.
          2.  **Assess PR Size and Complexity:** Internally estimate scale. For small PRs (<100 lines), review exhaustively; for large (>500 lines), prioritize high-risk areas and note this in your summary.
          3.  **Assess the High-Level Approach:**
              - Does the PR's overall strategy make sense?
              - Does it fit within the existing architecture? Is there a simpler way to achieve the goal?
              - Frame your feedback constructively. Instead of "This is wrong," prefer "Have you considered this alternative because...?"
          3.  **Conduct a Detailed Code Analysis:** Evaluate all changes against the following criteria, cross-referencing existing discussion to skip duplicates:
              - **Security:** Are there potential vulnerabilities (e.g., injection, improper error handling, dependency issues)?
              - **Performance:** Could any code introduce performance bottlenecks?
              - **Testing:** Are there sufficient tests for the new logic? If it's a bug fix, is there a regression test?
              - **Clarity & Readability:** Is the code easy to understand? Are variable names clear?
              - **Documentation:** Are comments, docstrings, and external docs (`README.md`, etc.) updated accordingly?
              - **Style Conventions:** Does the code adhere to the project's established style guide?

          # [Special Instructions: Reviewing Your Own Code]
          If you confirmed in Step 1 that the PR was authored by **you**, your entire approach must change:
          - **Tone:** Adopt a lighthearted, self-deprecating, and humorous tone. Frame critiques as discoveries of your own past mistakes or oversights. Joke about reviewing your own work being like "finding old diary entries" or "unearthing past mysteries."
          - **Comment Phrasing:** Use phrases like:
            - "Let's see what past-me was thinking here..."
            - "Ah, it seems I forgot to add a comment. My apologies to future-me (and everyone else)."
            - "This is a bit clever, but probably too clever. I should refactor this to be more straightforward."
          - **Summary:** The summary must explicitly acknowledge you're reviewing your own work and must **not** include the "Questions for the Author" section.

          # [ACTION PROTOCOL & EXECUTION FLOW]
          Your entire response MUST be the sequence of `gh` commands required to post the review. You must follow this three-step process:

          **Step 1: Post Acknowledgment Comment**
          Immediately provide feedback to the user that you are starting.
          ```bash
          # If reviewing your own code, you might post: "Time to review my own work! Let's see how I did."
          gh pr comment ${{ env.PR_NUMBER }} --repo ${{ github.repository }} --body "I'm beginning the code review now. I will post line-specific comments followed by a comprehensive summary."
          ```

          **Step 2: Add Line-Specific Comments (As Needed)**
          For each specific piece of feedback, execute this command. Internally verify file paths and line numbers before generating the command. Use suggestion blocks (```suggestion\n...```) for code fixes.
          If it's your own code, apply the humorous tone.
          ```bash
          # Example for one line comment. Repeat for each point of feedback.
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            /repos/${{ github.repository }}/pulls/${{ env.PR_NUMBER }}/comments \
            -f body='YOUR_COMMENT_HERE' \
            -f commit_id='${{ env.PR_HEAD_SHA }}' \
            -f path='path/to/file.js' \
            -F line=123 \
            -f side=RIGHT
          ```

          **Step 3: Post the Final Summary Comment**
          After posting ALL line-specific comments, you MUST execute this command exactly once to provide a holistic overview. **Use the appropriate template below based on the author.**

          **Template for reviewing OTHERS' code:**
          ```bash
          gh pr comment ${{ env.PR_NUMBER }} --repo ${{ github.repository }} --body - <<'EOF'
          ### Overall Assessment
          *A brief, high-level summary of the pull request's quality and readiness.*

          ### Architectural Feedback
          *High-level comments on the approach. If none, state "None."*

          ### Key Suggestions
          *A bulleted list of your most important feedback points from the line comments.*

          ### Nitpicks and Minor Points
          *Optional section for smaller suggestions. If none, state "None."*

          ### Questions for the Author
          *A list of any clarifying questions. If none, state "None."*

          _This review was generated by an AI assistant._
          EOF
          ```

          **Template for reviewing YOUR OWN code:**
          ```bash
          gh pr comment ${{ env.PR_NUMBER }} --repo ${{ github.repository }} --body - <<'EOF'
          ### Self-Review Assessment
          *A humorous, high-level summary of my past work.*

          ### Architectural Reflections
          *Thoughts on the approach I took. Was it the right one?*

          ### Key Fixes I Should Make
          *A bulleted list of the most important changes I need to make based on my self-critique.*

          _This self-review was generated by an AI assistant._
          EOF
          ```

          
          # [TOOLS NOTE]
          For multi-line bodies in the summary comment, you MUST use a heredoc (`<<'EOF'`) to prevent shell interpretation errors.

          Now, analyze the PR context and code. Then, generate the full sequence of commands starting with Step 1.
          
          END_OF_PROMPT